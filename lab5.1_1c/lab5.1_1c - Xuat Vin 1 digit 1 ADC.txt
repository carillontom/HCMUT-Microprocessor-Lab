;
; lab5.1_1c.asm
;
; Created: 11/18/2025 7:41:36 AM
; Author : huysk
;

.include "m324padef.inc"  
	.org 0x00
	rjmp  reset
	.org 0x50

reset:
    ldi r16, high(RAMEND)
    out SPH, r16
    ldi r16, low(RAMEND)
    out SPL, r16

configuration:
	;PORTA reads ADC
	;PORTB controls LCD
	;PORTD sends UART

	cbi ddra, 0 ;adc0  as input
	cbi porta, 0
	ldi r16, 0xff
	out ddrb, r16 

	call USART_Init
	call ADC_Init
	call LCD_Init			;-------Initiate LCD-------

	start: 
	call read_adc_16bit		;read ADC and store H-L byte to r17-r16
	call Send_char			;send r16
	call Calculator			;-------calculating Vin----------
	call LCD_Display		;-------Displaying on LCD--------
	call Timer_delay1s		
	rjmp start 

;--------------------LCD------------------------
LCD_Init:
	LDI R17, 0X03
	RCALL write_cmd_lcd	
	RCALL write_cmd_lcd
	RCALL write_cmd_lcd
	LDI R17, 0X02	;4-bit mode
	RCALL write_cmd_lcd
	LDI R17, 0x28	;Configures LCD interface: 4-bit data length, 2 display lines, and 5×8 font.
	RCALL write_cmd_lcd
	LDI R17, 0X01	;Delete everything on screen
	RCALL write_cmd_lcd
	LDI R17, 0X0C	;Display on, cursor off (must have)
	RCALL write_cmd_lcd
	LDI R17, 0X06	;Display on, cursor off (must have)
	RCALL write_cmd_lcd
	CLR R17
	RET

LCD_Display:		;Displaying R19 - R16 Vin
	PUSH R17
	LDI R17, 0X80
	RCALL write_cmd_lcd

	MOV R17, R16
	PUSH R16
	LDI R16, 48
	ADD R17, R16
	POP R16
	RCALL write_data_lcd

	LDI R17, 86		;Displaying 'V' for Volts
	RCALL write_data_lcd

	POP R17
	RET

;SUB FUNCTIONS FOR CALLING: write_cmd, write_data, delay2ms

write_cmd_lcd:
	PUSH R16
	MOV R16, R17	;R17 having the command's byte to be transfered
	ANDI R16, 0b11110000 ;keep the high nibble, sort out the lower nibble
	OUT PORTB, R16	;output to PB4-PB7
	CBI PORTB, 0	;RS = 0 cmd
	CBI PORTB, 1	;RW = 0
	SBI PORTB, 2	;EN = 1
	NOP
	CBI PORTB, 2	;EN = 0
	RCALL delay2ms	;delay for sleepy joe lcd to read
	MOV R16, R17	;move command's byte from R17 to R16 again
	SWAP R16	;swap LOW 4 bits with HIGH 4 bits
	ANDI R16, 0b11110000 ;keep the LOW nibble, sort out the HIGH nibble
	OUT PORTB, R16	;output to PB4-PB7
	CBI PORTB, 0	;RS = 0 cmd
	CBI PORTB, 1	;RW = 0
	SBI PORTB, 2	;EN = 1
	NOP
	CBI PORTB, 2	;EN = 0
	RCALL delay2ms	;delay for sleepy joe lcd to read
	POP R16
	RET

write_data_lcd:
	PUSH R16
	MOV R16, R17	;R17 having the data's byte to be transfered
	ANDI R16, 0b11110000 ;keep the high nibble, sort out the lower nibble
	OUT PORTB, R16	;output to PB4-PB7
	SBI PORTB, 0	;RS = 1 data
	CBI PORTB, 1	;RW = 0
	SBI PORTB, 2	;EN = 1
	NOP
	CBI PORTB, 2	;EN = 0
	RCALL delay2ms	;delay for sleepy joe lcd to read
	MOV R16, R17	;move data's byte from R17 to R16 again
	SWAP R16	;swap LOW 4 bits with HIGH 4 bits
	ANDI R16, 0b11110000 ;keep the LOW nibble, sort out the HIGH nibble
	OUT PORTB, R16	;output to PB4-PB7
	SBI PORTB, 0	;RS = 1
	CBI PORTB, 1	;RW = 0
	SBI PORTB, 2	;EN = 1
	NOP
	CBI PORTB, 2	;EN = 0
	RCALL delay2ms	;delay for sleepy joe lcd to read
	POP R16
	RET


;--------Vin calculator------------
;Currently R16 = ADCL and R17 = ADCH
;To calculate Vin, we multiply ADCValue by Vref = 5V and divide by 2^10 = 1024
;Multiply:
Calculator:
	MOV R18, R16
	MOV R19, R17
	LSL R16
	ROL R17
	LSL R16
	ROL R17
	ADD R16, R18
	ADC R17, R19	;ADC * 5
	LDI R20, 2
	ADD R17, R20	;Add 512 for rounding the number

;Divide, shift 10 bit right
	CLR R18
	CLR R19
	ANDI R16, 0X00
	MOV R16, R17
	LSR R16
	LSR R16
	RET		;ADC * 5 / 1024 R16

;--------sending chars-----------
Send_char:
	push r16
	push r16
	push r17

	ldi r16, 0x55
	call USART_SendChar 

	mov r16, r17
	call USART_SendChar 

	pop r17 
	pop r16
	call USART_SendChar 

	ldi r16, 0xFF
	call USART_SendChar 
	pop r16
	ret


;-----------------init ADC---------------------
;init the ADC with reference voltage to AVCC,  select ADC channel 0 
;set ADC clock to 125Khz with 8Mhz CPU clock
ADC_Init: 
	ldi r16, (1<<REFS0)  ; set reference voltage to AVCC, ADC channel 0   
	sts ADMUX, r16  ; store the value in ADMUX register 
	ldi  r16, (1<<ADEN) | (1<<ADPS2) | (1<<ADPS1) | (1<<ADPS0) ; prescaler = 128
	sts  ADCSRA, r16 ; write to ADCSRA register 
	nop 
	ret         
  
;start a single conversion  
;read ADC and store H-L byte to r17-r16                
read_adc_16bit: 
	push r18 
	lds r18, ADCSRA 
	ori r18, (1<<ADSC) 
	sts ADCSRA, r18 

 read_adc_16bit_wait: 
	 lds  r18,ADCSRA 
	 andi r18, (1<<ADSC) 
	 cpi  r18, (1<<ADSC) 
	 breq read_adc_16bit_wait	;if ADSC of ADCSRA = 1 means the system still busy -> wait
	 lds  r16, ADCL             ; read ADCL first 
	 lds  r17, ADCH             ; read ADCH second 
	 pop  r18 
	 ret 

;-----------------init UART 0---------------------
;CPU clock is 8Mhz 
USART_Init: 
	ldi r16, 103
	sts UBRR0L, r16 
    ldi r16, (1 << U2X0) 
    sts UCSR0A, r16 
    ; Set frame format: 8 data bits, no parity, 1 stop bit 
    ldi r16, (1 << UCSZ01) | (1 << UCSZ00) 
    sts UCSR0C, r16 
    ; Enable transmitter and receiver 
    ldi r16, (1 << RXEN0) | (1 << TXEN0) 
    sts UCSR0B, r16 
	clr r16
    ret 

;send out 1 byte in r16 
USART_SendChar: 
 push r17 
    ; Wait for the transmitter to be ready 
    USART_SendChar_Wait: 
  lds r17, UCSR0A 
        sbrs r17, UDRE0 ;check USART Data Register Empty bit 
        rjmp USART_SendChar_Wait 
       sts UDR0, r16  ;send out 
 pop r17 
    ret 



;----------------Delay functions-----------------------
;----------------Delay 1s by timer---------------------
Timer_delay32ms:
	push r17
//timer 0 NOR
    ldi r17, 0x00
    out TCCR0A, r17
//timer 0 nor stop
    ldi r17, 0x00
    out TCCR0B, r17
    ldi r17, 0          ; preload = 0 ? count full 0..255
    out TCNT0, r17
    ldi r17, 0x00
    out TCCR0A, r17
    ldi r17, (1<<CS02) | (1<<CS00)   ; prescaler = 1024 (max)
    out TCCR0B, r17
wait:
    SBIS TIFR0, TOV0
    RJMP wait
    SBI TIFR0, TOV0
    LDI R17, 0x00
    OUT TCCR0B, R17
	pop r17
    RET

Timer_delay1s:
    push r18              ; preserve caller’s r18
    ldi  r18, 31          ; 31 × 32.768 ms ? 1.016 s
Delay_1s_loop:
    rcall Timer_delay32ms ; call your 32 ms timer
    dec  r18
    brne Delay_1s_loop
    pop  r18              ; restore
    ret

delay2ms:
	 PUSH R23
	 PUSH R24
	 PUSH R25
	 PUSH R26
	 LDI R26, 1
LP0: LDI R25, 12
LP1: LDI R23, 40
LP2: LDI R24, 10
LP3:
    DEC R24
    BRNE LP3

    DEC R23
    BRNE LP2

    DEC R25
    BRNE LP1

    DEC R26
    BRNE LP0
	POP R26
	POP R25
	POP R24
	POP R23
    RET

